/**
 * generated by Xtext 2.25.0
 */
package uk.ac.kcl.inf.validation;

import com.google.common.collect.Iterators;
import java.util.Arrays;
import java.util.List;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.xbase.lib.Functions.Function2;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import uk.ac.kcl.inf.simpMusic.Amplitude;
import uk.ac.kcl.inf.simpMusic.LoopNote;
import uk.ac.kcl.inf.simpMusic.Note;
import uk.ac.kcl.inf.simpMusic.SimpMusicPackage;
import uk.ac.kcl.inf.simpMusic.SimpleMusic;
import uk.ac.kcl.inf.simpMusic.Sleep;
import uk.ac.kcl.inf.simpMusic.Solfege;
import uk.ac.kcl.inf.simpMusic.SolfegeWithModification;
import uk.ac.kcl.inf.simpMusic.Timbre;
import uk.ac.kcl.inf.simpMusic.Tone;
import uk.ac.kcl.inf.simpMusic.ToneType;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class SimpMusicValidator extends AbstractSimpMusicValidator {
  public static final String INVALID_TONE = "uk.ac.kcl.inf.SimpMusic.INVALID_VARIABLE_NAME";
  
  public static final String INVALID_LOOP_COUNT = "uk.ac.kcl.inf.SimpMusic.INVALID_LOOP_COUNT";
  
  public static final String INVALID_MOD_COUNTS = "uk.ac.kcl.inf.SimpMusic.INVALID_MOD_COUNTS";
  
  public static final String MAY_NOT_COMPLETE = "uk.ac.kcl.inf.SimpMusic.valMAY_NOT_COMPLETE";
  
  private int totalPulsesCount = 0;
  
  @Check
  public void checkMaximumAndMinimumValueOfTone(final Tone tone) {
    final ToneType toneType = tone.getTone();
    final int toneValue = tone.getVal();
    if (((toneType == ToneType.HIGH) && (toneValue > 9))) {
      this.warning("The modification of tune should not be greater than 9", tone, SimpMusicPackage.Literals.TONE__VAL, 
        SimpMusicValidator.INVALID_TONE);
    } else {
      if (((toneType == ToneType.SUB) && (toneValue > 4))) {
        this.warning("The modification of tune should not be less than -4", tone, SimpMusicPackage.Literals.TONE__VAL, 
          SimpMusicValidator.INVALID_TONE);
      }
    }
  }
  
  @Check
  public void checkLoopValue(final LoopNote note) {
    int _count = note.getCount();
    boolean _lessEqualsThan = (_count <= 0);
    if (_lessEqualsThan) {
      this.warning("Loop count must be greater than 0", note, SimpMusicPackage.Literals.LOOP_NOTE__COUNT, 
        SimpMusicValidator.INVALID_LOOP_COUNT);
    }
  }
  
  @Check
  public void checkModificationCounts(final SolfegeWithModification swm) {
    int _size = IteratorExtensions.size(Iterators.<Amplitude>filter(swm.eAllContents(), Amplitude.class));
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      final Procedure1<Amplitude> _function = (Amplitude element) -> {
        this.warning("amount of Amplitude should not be more than 1", element, 
          SimpMusicPackage.Literals.AMPLITUDE__AMP, SimpMusicValidator.INVALID_MOD_COUNTS);
      };
      IteratorExtensions.<Amplitude>forEach(Iterators.<Amplitude>filter(swm.eAllContents(), Amplitude.class), _function);
    }
    int _size_1 = IteratorExtensions.size(Iterators.<Timbre>filter(swm.eAllContents(), Timbre.class));
    boolean _greaterThan_1 = (_size_1 > 1);
    if (_greaterThan_1) {
      final Procedure1<Timbre> _function_1 = (Timbre element) -> {
        this.warning("amount of Timbre should not be more than 1", element, SimpMusicPackage.Literals.TIMBRE__TIMBRE, 
          SimpMusicValidator.INVALID_MOD_COUNTS);
      };
      IteratorExtensions.<Timbre>forEach(Iterators.<Timbre>filter(swm.eAllContents(), Timbre.class), _function_1);
    }
    int _size_2 = IteratorExtensions.size(Iterators.<Tone>filter(swm.eAllContents(), Tone.class));
    boolean _greaterThan_2 = (_size_2 > 1);
    if (_greaterThan_2) {
      final Procedure1<Tone> _function_2 = (Tone element) -> {
        this.warning("amount of Tone should not be more than 1", element, SimpMusicPackage.Literals.TONE__TONE, 
          SimpMusicValidator.INVALID_MOD_COUNTS);
      };
      IteratorExtensions.<Tone>forEach(Iterators.<Tone>filter(swm.eAllContents(), Tone.class), _function_2);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkTotalBeats(final SimpleMusic sm) {
    this.totalPulsesCount = 0;
    Boolean _checkAlwaysMultiple2or3 = this.checkAlwaysMultiple2or3(sm.getNotes());
    boolean _not = (!(_checkAlwaysMultiple2or3).booleanValue());
    if (_not) {
      this.warning("The song may not be completed (wrong number of beats)", sm, 
        SimpMusicPackage.Literals.SIMPLE_MUSIC__NOTES, SimpMusicValidator.MAY_NOT_COMPLETE);
    }
  }
  
  private Boolean checkAlwaysMultiple2or3(final List<Note> notes) {
    final Function2<Boolean, Note, Boolean> _function = (Boolean prev, Note stmt) -> {
      return Boolean.valueOf(this.addBeatsAndCheck(stmt));
    };
    return IterableExtensions.<Note, Boolean>fold(notes, Boolean.valueOf(true), _function);
  }
  
  private boolean _addBeatsAndCheck(final Note note) {
    return this.checkMultiple2or3(this.totalPulsesCount);
  }
  
  private boolean _addBeatsAndCheck(final Solfege note) {
    boolean _xblockexpression = false;
    {
      this.totalPulsesCount++;
      _xblockexpression = this.checkMultiple2or3(this.totalPulsesCount);
    }
    return _xblockexpression;
  }
  
  private boolean _addBeatsAndCheck(final Sleep note) {
    boolean _xblockexpression = false;
    {
      this.totalPulsesCount++;
      _xblockexpression = this.checkMultiple2or3(this.totalPulsesCount);
    }
    return _xblockexpression;
  }
  
  private boolean _addBeatsAndCheck(final SolfegeWithModification note) {
    boolean _xblockexpression = false;
    {
      this.totalPulsesCount++;
      _xblockexpression = this.checkMultiple2or3(this.totalPulsesCount);
    }
    return _xblockexpression;
  }
  
  private boolean _addBeatsAndCheck(final LoopNote note) {
    boolean _xblockexpression = false;
    {
      boolean result = true;
      for (int i = 0; (i < note.getCount()); i++) {
        result = (this.checkAlwaysMultiple2or3(note.getNotes())).booleanValue();
      }
      _xblockexpression = result;
    }
    return _xblockexpression;
  }
  
  private boolean checkMultiple2or3(final int number) {
    return (((number % 2) == 0) || ((number % 3) == 0));
  }
  
  private boolean addBeatsAndCheck(final Note note) {
    if (note instanceof LoopNote) {
      return _addBeatsAndCheck((LoopNote)note);
    } else if (note instanceof Sleep) {
      return _addBeatsAndCheck((Sleep)note);
    } else if (note instanceof Solfege) {
      return _addBeatsAndCheck((Solfege)note);
    } else if (note instanceof SolfegeWithModification) {
      return _addBeatsAndCheck((SolfegeWithModification)note);
    } else if (note != null) {
      return _addBeatsAndCheck(note);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(note).toString());
    }
  }
}
