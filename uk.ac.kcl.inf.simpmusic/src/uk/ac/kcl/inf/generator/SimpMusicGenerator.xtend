/*
 * generated by Xtext 2.25.0
 */
package uk.ac.kcl.inf.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import uk.ac.kcl.inf.simpMusic.AmpType
import uk.ac.kcl.inf.simpMusic.Amplitude
import uk.ac.kcl.inf.simpMusic.LoopNote
import uk.ac.kcl.inf.simpMusic.Note
import uk.ac.kcl.inf.simpMusic.SimpleMusic
import uk.ac.kcl.inf.simpMusic.Sleep
import uk.ac.kcl.inf.simpMusic.Solfa
import uk.ac.kcl.inf.simpMusic.Solfege
import uk.ac.kcl.inf.simpMusic.SolfegeWithModification
import uk.ac.kcl.inf.simpMusic.Timbre
import uk.ac.kcl.inf.simpMusic.TimbreType
import uk.ac.kcl.inf.simpMusic.Tone
import uk.ac.kcl.inf.simpMusic.ToneType

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SimpMusicGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.contents.head as SimpleMusic
		fsa.generateFile(deriveTargetFileNameFor(model, resource), model.generate)
	}

	def deriveTargetFileNameFor(SimpleMusic music, Resource resource) {
		resource.URI.appendFileExtension('txt').lastSegment
	}

	def CharSequence generate(SimpleMusic music) '''
		«music.notes.map[generateNote].join('\n')»
	'''

	dispatch def String generateNote(Note note) ''''''

	dispatch def String generateNote(Solfege note) {
		'''«getBasicNote(note.note)»''' + "\n" + "sleep 0.5"
	}

	def getBasicNote(Solfa solfa) '''«switch (solfa) {
			case Solfa.DO: "play :C"
			case Solfa.RE: "play :D"
			case Solfa.MI: "play :E"
			case Solfa.FA: "play :F"
			case Solfa.SOL: "play :G"
			case Solfa.LA: "play :A"
			case Solfa.SI: "play :B"
			default: ""
		}»'''

	dispatch def String generateNote(Sleep note) '''sleep 0.5'''

	dispatch def String generateNote(SolfegeWithModification note) {
		val basicNote = '''«getBasicNote(note.note.note)»'''
		var mod = '''«note.mods.map[generateModification].join('')»'''

		// modification must follow the order: timbre > tone > amplitude
		// move amplitude to the last one
		if (mod.contains(", amp: 0.5") || mod.contains(", amp: 1.5")) {
			val type = mod.contains(", amp: 0.5") ? ", amp: 0.5" : ", amp: 1.5"
			mod = mod.replaceFirst(", amp: [0-9][.][0-9]", "")
			mod += type
		}

		// move timbre to the first one
		if (mod.contains("[[s]]") || mod.contains("[[b]]")) {
			val timbre = mod.substring(mod.indexOf("[[") + 2, mod.indexOf("]]"))
			mod = mod.replaceFirst("\\[\\[(s|b)\\]\\]", "")
			mod = timbre + mod
		}
		basicNote + mod + "\n" + "sleep 0.5"
	}

	dispatch def String generateNote(LoopNote note) '''
		«IF note.count > 0»«note.count».times do
			«FOR stm : note.notes»
				«generateNote(stm)»
			«ENDFOR»
		end«ENDIF»
	'''

	dispatch def String generateModification(Amplitude mod) ''', amp: «IF mod.amp === AmpType.WEAK»0.5«ELSE»1.5«ENDIF»'''

	dispatch def String generateModification(
		Timbre mod) '''«IF mod.timbre === TimbreType.SHARP»[[s]]«ELSE»[[b]]«ENDIF»'''

	dispatch def String generateModification(
		Tone mod) '''«IF mod.tone === ToneType.HIGH»«4 + mod.^val»«ELSE»«4 - mod.^val»«ENDIF»'''

}
